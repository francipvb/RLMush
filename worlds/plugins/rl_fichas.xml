<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient [
  <!ENTITY prefijo "\$" >
  ]>
<!-- Saved on domingo, julio 08, 2018, 2:55 a. m. -->
<!-- MuClient version 5.05 -->

<!-- Plugin "rl_fichas" generated by Plugin Wizard -->

<muclient>
<plugin
   name="rl_fichas"
   author="Francisco R. Del Roio"
   id="f7823bfe980222e6736c9b69"
   language="Lua"
   purpose="Administra perfiles de clase y raza para personajes de reinos de leyenda."
   date_written="2018-07-08 02:50:38"
   requires="4.94"
   version="1.0"
   >
<description trim="y">
<![CDATA[
	Este plugin se encarga de gestionar todo lo relativo a los alias del cliente para personajes, clases, razas, escuelas y esferas.

	Comandos disponibles:
	$calias <opciones> <enviar> <comando>
		Añade un alias de cliente al perfil de clase para el personaje conectado actualmente.
		
		- opciones: Ver abajo.
		- enviar: El comando, por ejemplo, f1 o ^1(\d*?)$ si se agrega una expresión regular.
		- comando: El comando que se envía al MUD. Se pueden usar substituciones como %1, %2, etc.

	$palias <opciones> <enviar> <comando>
		Añade un alias de cliente  al perfil del personaje conectado.
		
		La entrada es igual que para el comando $calias.

	$ oalias <opciones> <enviar> <comando>
		Añade un alias al perfil de oficio.
		
		Este comando no está implementado.

	$falias <esfera> <acceso> <enviar> <comando>
		Agrega un alias de cliente al perfil de la esfera.
		
		- esfera: Nombre de la esfera a la que se añade el comando.
		- acceso: Nivel de acceso
			1. Acceso a menor, se añade siempre que la clase tenga dicha esfera.
			2. El comando se añade solo si el personaje tiene acceso a neutral o mayor.
			3. Se añade solo si el personaje tiene acceso a mayor en la esfera.

		ver mas arriba para el resto de opciones.

	$ealias <escuela> <acceso> <enviar> <comando>
		Ver $falias, aplicado a escuelas.

	$ead <escuela> <acceso>
		Añade una escuela a la clase del personaje.
		
		- escuela: Nombre de la escuela que se agrega. De no existir, se carga una plantilla vacía en la memoria.
		- acceso: El nivel de acceso a la escuela.
			1. Acceso a menor.
			2. Acceso a neutral.
			3. Acceso a mayor.

	$ fadd <esfera> <acceso>
		Ver $eadd, aplicale a esferas.

	$ guardar <tipo>[ <nombre>]
		Escribe los datos para un objeto en el disco.
		
		- Tipo: El tipo de objeto que se va a escribir al disco.
			- clase: Se guarda el archivo de clase actualmente usado, con sus alias, nombre y esferas/escuelas.
			- personaje: Se guarda el archivo de personaje con sus propios alias.
			- oficio: Se guarda el archivo para el oficio.
			- esfera: Se guarda la esfera indicada al disco.
			- escuela: Se guarda la escuela indicada al disco.
			- todo: Se guardan todos los objetos relacionados con el personaje al disco (no implementado).
		
		- escuela/esfera: Indica la esfera o escuela que se guarda al disco.
	
	Decidí separar las escuelas y las esferas para mayor flexibilidad, aunque no se si sea del todo necesario.
]]>
</description>

</plugin>

<aliases>
  <alias
   match="^&prefijo;(?P&lt;tipo&gt;p|c|r|o)alias (?P&lt;opts&gt;\-[xvi]+ |)(?P&lt;alias&gt;\w+|\^.*?\$) (?P&lt;comando&gt;.*?)$"
   script="on_alias"
   regexp="y"
   sequence="100"
   enabled="y"
   name="alias"
  >
  </alias>

  <alias
   enabled="y"
   match="^&prefijo;(?P&lt;tipo&gt;f|e)alias (?P&lt;nombre&gt;[a-z]+) (?P&lt;acceso&gt;1|2|3) (?P&lt;opts&gt;\-[xvi]+ |)(?P&lt;alias&gt;[a-zA-Z0-9]+|\^.*?\$) (?P&lt;comando&gt;.*?)$"
   script="on_alias"
   regexp="y"
   sequence="100"
   name="magia"
  >
  </alias>
  
  <alias
   enabled="y"
   match="^&prefijo;guardar (clase|personaje|raza|oficio|(?P&lt;etipo&gt;escuela|esfera) (?P&lt;nombre&gt;[a-z]+))$"
   script="on_guardar"
   regexp="y"
   sequence="100"
  >
  </alias>

  <alias
   enabled="y"
   match="^&prefijo;(?P&lt;tipo&gt;e|f)add (?P&lt;nombre&gt;\w+) (?P&lt;acceso&gt;1|2|3)$"
   script="on_agregar"
   regexp="y"
   sequence="100"
  >
  </alias>
</aliases>

<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Script  -->





<script>
<![CDATA[
require "rl_stuff"

local clases = {}
local esferas = {}
local escuelas = {}
local oficios = {}
local personajes = {}

local function cargar_objeto(nombre)
	-- Validamos el nombre primero.
	assert(type(nombre) == "string", "El nombre de archivo no es válido.")
	
	-- Abrimos el archivo, si es que existe. En caso contrario, cerramos.
	local archivo, error = io.open(GetInfo(67)..nombre, "r")
	assert(archivo, error)
	
	-- Leemos todo el archivo
	local cadena = archivo:read("*a")
	
	-- Cerramos el archivo
	archivo:close()

	return assert(loadstring("return "..cadena)(), "El contenido del archivo no es válido.")
end -- function

local function guardar_objeto(objeto, nombre)
	require "serialize"
	
	-- Validamos el nombre de archivo y el objeto
	assert(objeto, "No se pasó ningún objeto válido.")
	assert(nombre, "No se pasó ningún nombre de archivo.")
	assert(type(objeto) == "table", "Solo se admiten objetos de tipo table para guardar.")
	assert(type(nombre) == "string", "No se admiten otro tipo de formatos a no ser cadenas en el nombre de archivo.")
	
	-- El primer paso es obtener la representación json del objeto.
	-- Para evitar poner asserts innecesarios los errores no se controlarán.
	local resultado = serialize.save_simple(objeto)
	
	-- Abrimos el archivo
	local archivo, mensaje = io.open(GetInfo(67)..nombre, "w+")
	assert(archivo, mensaje)
	
	-- Escribimos los datos
	archivo:write(resultado)
	archivo:close()
end -- function

local function agregar_alias(objeto)
	check(AddAlias("", objeto.alias, objeto.comando, (function()
		-- Esta función devuelve los flags para el alias trducidos a mushclient
		local flags = alias_flag.Enabled + alias_flag.Temporary
		
		if objeto.ignorar then
			flags = flags + alias_flag.IgnoreAliasCase
		end -- v.ignorar
		
		if objeto.variables then
			flags = flags + alias_flag.ExpandVariables
		end -- v.variables
		
		if objeto.regexp then
			flags = flags + alias_flag.RegularExpression
		end -- v.regexp
		
		return flags
	end)(), ""))
end -- function

local function cargar(tipo, clase)
	assert(clase, "No se pasó ningún argumento.")
	assert(type(clase) == "string", "El nombre no es una cadena válida.")
	assert(#clase > 0, "El nombre no puede ser una cadena vacía.")
	assert(tipo > 0 and tipo <= 6, "El tipo no es válido.")
	
	-- Variables
	local carpeta
	
	if tipo == 1 then
		carpeta = "clases"
	elseif tipo == 2 then
		carpeta = "razas"
	elseif tipo == 3 then
		carpeta = "oficios"
	elseif tipo == 4 then
		carpeta = "escuelas"
	elseif tipo == 5 then
		carpeta = "esferas"
	else
		carpeta = "perfiles"
	end -- if
	
	-- Construimos el nombre del objeto basados en la información que tenemos
	local archivo = string.format("rlmud\\%s\\%s.rl", carpeta, clase)
	
	return cargar_objeto(archivo)
end -- function

local function get_clase(nombre)
	if not clases[nombre] then
		local resultado, clase, mensaje = pcall(cargar, 1, nombre)

		if not resultado then
			print(string.format("No existe un archivo para la clase \"%s\". Se generará uno nuevo.", var.clase))
			
			-- Aprobecho para definir el formato de referencia del objeto clase
			clases[nombre] = {
				nombre = nombre,
				-- Por defecto es el nombre de clase a secas, pero se podrá cambiar proximamente.
				nombre_completo = nombre,

				-- Esta es una lista de los alias que se añaden temporalmente cuando se carga la clase.
				comandos = {},

				-- Esto es para definir otros perfiles de alias que puedan cargarse, usado para clases mágicas principalmente
				-- Estas listas no se definen en los demás contenedores
				esferas = {},
				escuelas = {},

				-- Podría incluir mas información, pero no se me ocurre nada de momento y tampoco es necesario.
			}
		else
			clases[nombre] = clase
		end -- if
	end -- if
	
	return clases[nombre]
end -- clase

local function get_esfera(nombre)
	if not esferas[nombre] then
		local resultado, esfera = pcall(cargar, 5, nombre)
		
		if not resultado then
			esferas[nombre] = {
				-- Defino el formato de las esferas aquí, serán similares las escuelas y las esferas
				nombre = nombre,
				nombre_completo = nombre,
				
				-- Estos alias se cargan para las clases que tengan la esfera en cualquier acceso
				comandos_menor = {},
				
				-- Estos se cargan cuando el comando es válido para un acceso a neutral
				comandos_neutral = {},
				
				-- Estos cuando la clase es experta en una escuela/esfera
				comandos_mayor = {}
			}
		else
			esferas[nombre] = esfera
		end -- if
	end -- if
	
	return esferas[nombre]
end -- function

local function get_escuela(nombre)
	if not esferas[nombre] then
		local resultado, esfera = pcall(cargar, 4, nombre)
		
		if not resultado then
			escuelas[nombre] = {
				nombre = nombre,
				nombre_completo = nombre,
				comandos_menor = {},
				comandos_neutral = {},
				comandos_mayor = {}
			}
		else
			escuelas[nombre] = esfera
		end -- if
	end -- if
	
	return escuelas[nombre]
end -- function

local function get_personaje(nombre)
	if not personajes[nombre] then
		local resultado, ficha, mensaje = pcall(cargar, 6, nombre)
		
		if not resultado then
			personajes[nombre] = {
				nombre = nombre,
				nombre_completo = nombre,
				comandos = {}
			}
		else
			personajes[nombre] = ficha
		end -- if
	end -- fichas
	
	return personajes[nombre]
end -- get_ficha

local function guardar(tipo, clase)
	assert(clase, "No se pasó ningún argumento.")
	assert(type(clase) == "string", "El nombre no es una cadena válida.")
	assert(#clase > 0, "El nombre no puede ser una cadena vacía.")
	assert(tipo > 0 and tipo <= 6, "El tipo no es válido.")
	
	-- Variables
	local carpeta, obj, stipo
	
	if tipo == 1 then
		carpeta = "clases"
		obj = get_clase(clase)
		stipo = string.format("la clase \"%s\"", obj.nombre_completo)
	elseif tipo == 2 then
		carpeta = "razas"
		stipo = "la raza \"%s\""
	elseif tipo == 3 then
		carpeta = "oficios"
		stipo = "el oficio"
	elseif tipo == 4 then
		obj = get_escuela(clase)
		carpeta = "escuelas"
		stipo = string.format("la escuela \"%s\"", obj.nombre_completo)
	elseif tipo == 5 then
		obj = get_esfera(clase)
		carpeta = "esferas"
		stipo = string.format("la esfera \"%s\"", obj.nombre_completo)
	else
		obj = get_personaje(clase)
		carpeta = "perfiles"
		stipo = string.format("el perfil para %s", obj.nombre_completo)
	end -- if
	
	-- Construimos el nombre del objeto basados en la información que tenemos
	local archivo = string.format("rlmud\\%s\\%s.rl", carpeta, clase)
	print(string.format("Se va a guardar %s en el disco duro.", stipo))
	return guardar_objeto(obj, archivo)
end -- function

local function cargar_magia(obj, acceso)
	if acceso >= 1 then
		for ki, vi in pairs(obj.comandos_menor) do
			agregar_alias(vi)
		end -- comandos a menor
	end -- acceso menor
	
	if acceso >= 2 then
		for ki, vi in pairs(obj.comandos_neutral) do
			agregar_alias(vi)
		end -- comandos a neutral
	end -- acceso a neutral

	if acceso >= 3 then
		for ki, vi in pairs(obj.comandos_mayor) do
			agregar_alias(vi)
		end -- comandos a mayor
	end -- acceso a mayor
end -- cargar_magia

local function cargar_esfera(nombre, acceso)
	local esfera = get_esfera(nombre)
	cargar_magia(esfera, acceso)
end -- cargar_esfera

local function cargar_escuela(nombre, acceso)
	local escuela = get_escuela(nombre)
	cargar_magia(escuela, acceso)
end -- cargar_esfera

local function recargar_todo()
	require "var"
	require "check"
	
	-- Primero que nada eliminamos todos los alias temporales
	DeleteTemporaryAliases()
	
	-- Primero que nada cargamos la clase
	if var.clase then
		-- Si la clase no está cargada, la carga. En caso de que no exista, generará una clase vacía.
		local clase = get_clase(var.clase)
		
		-- Cargamos los comandos para la clase
		for k, v in pairs(clase.comandos) do
			-- Sencillamente añadimos el alias
			agregar_alias(v)
		end -- clase.comandos
		
		-- Ahora las escuelas y esferas
		for k, v in pairs(clase.esferas) do
			cargar_esfera(v.nombre, v.acceso)
		end -- esferas
		
		for k, v in pairs(clase.escuelas) do
			cargar_escuela(v.nombre, v.acceso)
		end -- esferas
	end -- if
	
	if var.raza then
	end -- if
	if var.oficio then
	end -- if
	
	if var.nombre then
		local ficha = get_personaje(var.nombre)
		
		-- cargamos los comandos agregados a la ficha
		for k, v in pairs(ficha.comandos) do
			agregar_alias(v)
		end -- for
	end -- if
end -- function

function on_alias(nombre,linea,wc)
	require "check"
	require "var"
	
	if not var.clase then
		print("No hay una clase definida.")
		return
	end -- if
	
	-- Obtenemos la clase por conveniencia
	local clase = get_clase(var.clase)
	
	local regexp = wc.opts:find("x")
	local variables = wc.opts:find("v")
	local ignorar = wc.opts:find("i")

	-- Generamos el alias
	local alias = {
		alias = wc.alias,
		comando = wc.comando,

		-- Este flag define si se usan las variables definidas en mushclient
		variables = not not variables,

		-- Este flag indica si el comando es una expresión regular.
		regexp = not not regexp,

		-- Si es true, las mayúsculas y minúsculas no se respetan.
		ignorar = not not ignorar
	}

	if wc.tipo == "c" then
		-- Sencillamente agregamos el alias a la tabla de la clase
		table.insert(clase.comandos, alias)
		print(string.format("El alias se agregó a la clase %s.", clase.nombre_completo))
	elseif wc.tipo == "p" then
		local ficha = get_personaje(var.nombre)
		table.insert(ficha.comandos, alias)
		print(string.format("Se agregó el alias al perfil d%s.", ficha.nombre_completo))
	elseif wc.tipo == "e" or wc.tipo == "f" then
		-- Este es el caso de las escuelas/esferas
		local obj
		
		if wc.tipo == "f" then
			obj = get_esfera(wc.nombre)
		else
			obj = get_escuela(wc.nombre)
		end -- tipo
		
		-- Ahora comprobamos el acceso
		local acceso = tonumber(wc.acceso)
		
		if acceso == 1 then -- menor
			table.insert(obj.comandos_menor, alias)
			print(string.format("Se agregó el alias a la lista de comandos de acceso a menor para %s.", wc.nombre))
		elseif acceso == 2 then
			table.insert(obj.comandos_neutral, alias)
			print(string.format("Se agregó el alias a la lista de comandos de acceso a neutral para %s.", wc.nombre))
		else
			table.insert(obj.comandos_mayor, alias)
			print(string.format("Se agregó el alias a la lista de comandos de acceso a mayor para %s.", wc.nombre))
		end -- acceso
	end -- if
	
	-- Ahora recargamos todo para poder comprobar que todo fue bien
	recargar_todo()
end -- function

function on_agregar(name,line,wc)
	require "var"
	
	if not var.nombre then
		print("No hay ningún personaje conectado.")
		return
	end -- if
	
	local clase = get_clase(var.clase)
	
	-- La forma en string de los niveles de acceso
	local acceso = tonumber(wc.acceso)
	
	if acceso == 1 then
		acceso = "menor"
	elseif acceso == 2 then
		acceso = "neutral"
	else
		acceso = "mayor"
	end -- if
	
	if wc.tipo == "f" then
		print(string.format("Añadiendo la esfera %s a la clase %s con nivel de acceso %s.", wc.nombre, clase.nombre_completo, acceso))
		table.insert(clase.esferas, {
			nombre = wc.nombre,
			acceso = tonumber(wc.acceso)
		})
	else
		print(string.format("Añadiendo la escuela %s a la clase %s con nivel de acceso %s.", wc.nombre, clase.nombre_completo, acceso))
		table.insert(clase.escuelas, {
			nombre = wc.nombre,
			acceso = tonumber(wc.acceso)
		})
	end -- if
	
	recargar_todo()
end -- function

function on_guardar(name,line,wildcards)
	require "var"
	local args = wildcards[1]
	
	if args == "clase" then
		guardar(1, var.clase)
	elseif args == "oficio" then
		guardar(2, var.oficio)
	elseif args == "raza" then
		guardar(3, var.raza)
	elseif args == "personaje" then
		guardar(6, var.nombre)
	else
		if wildcards.etipo == "escuela" then
			guardar(4, wildcards.nombre)
		else
			guardar(5, wildcards.nombre)
		end -- if
	end -- if
end -- function

function OnPluginListChanged()
	RLStuffListChanged()
	subscribir("Core.Hello", "on_conectar")
	subscribir("Core.Goodbye", "on_salir")
	subscribir("Char.Ficha", "on_ficha")
end -- function

function on_conectar(mensaje)
	require "var"
	
	var.clase = nil
	var.oficio = nil
	var.raza = nil
	var.nombre = nil
end -- function

function on_salir(mensaje)
	require "var"
	
	var.clase = nil
	var.oficio = nil
	var.raza = nil
	var.nombre = nil
end -- function

function on_ficha(mensaje, datos)
	require "var"
	require "json"
	
	-- Parseamos los datos mediante json
	local ficha = json.decode(datos)
	
	-- Si se define la clase, reemplazamos la variable con el valor nuevo
	if ficha.clase then
		var.clase = ficha.clase
	end -- if
	
	-- Igual el oficio
	if ficha.oficio then
		var.oficio = ficha.oficio
	end -- if
	
	-- Igual con la raza, aunque es poco probable que tengan comandos propios
	if ficha.raza then
		var.raza = ficha.raza
	end -- if
	
	if ficha.nombre then
		var.nombre = ficha.nombre
	end -- if
	
	recargar_todo()
end -- function

function OnPluginInstall()
	if IsConnected() then
		recargar_todo()
	end -- if
end -- function

function OnPluginClose()
	desuscribir("Core.Hello", "on_conectar")
	desuscribir("Core.Goodbye", "on_salir")
	desuscribir("Char.Ficha", "on_ficha")
	DeleteTemporaryAliases()
end -- function

]]>
</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="rl_fichas:help"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[
function OnHelp ()
  world.Note (world.GetPluginInfo (world.GetPluginID (), 3))
end
]]>
</script> 

</muclient>
