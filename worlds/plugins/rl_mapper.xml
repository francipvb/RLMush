<?xml version="1.0" encoding="iso8859-15"?>
<!DOCTYPE muclient [
  <!ENTITY prefijo "(?:(?:.*?)(?:\&gt; |\] |\} )|)" >
  <!ENTITY intens "(?:(con |)(débilmente |poca fuerza |fuerza |mucha fuerza |violentamente |fuerza sobrehumana |fuerza divina |increíble potencia |cólera titánica |))" >
  ]>
<!-- Saved on domingo, mayo 07, 2017, 5:49 p.m. -->
<!-- MuClient version 4.94 -->

<!-- Plugin "rl_mapper" generated by Plugin Wizard -->

<muclient>
<plugin
   name="rl_mapper"
   author="Francisco R. Del Roio"
   id="e634c782be2e150ffc27eded"
   language="Lua"
   purpose="Un mapeador para reinos de leyenda que funciona con mushclient."
   date_written="2017-05-07 17:47:06"
   requires="4.94"
   version="1.0"
   save_state="y"
   >
<description trim="y">
<![CDATA[
	Mapa de Reinos de leyenda
	
	Este plugin añade el soporte para un mapa de reinos de leyenda MUD.
	
	Estos son los comandos disponibles por ahora:
	
	General:
	- mapa ayuda 				 - Este mensaje de ayuda
	- mapa mostrar  			 - Muestra la vista gráfica del mapa.
	- mapa ocultar 			 - Oculta la vista gráfica del mapa.
	
	Búsqueda y navegación:
	- mapa navegar <texto> 	 - Realiza una búsqueda de texto completo entre las salas cercanas y ofrece una lista si hay muchas posibilidades. En caso de existir solo una, comenzará a navegar hasta ella automáticamente.
	- mapa buscar <texto> 	 - Realiza una búsqueda de texto completo entre todas las salas del MUD y la que se seleccione será marcada como la sala actual.
	
	Base de Datos:
	- mapa importar 		 - Importa el mapa desde una base de datos (solo soporta mapas de ZMud).
	
	Este plugin tiene unas cuantas carencias:
	
	1. El plugin se apoya totalmente en el módulo llamado "mapper.lua" incluido con MUSHClient, por lo que todos los mensajes relacionados directamente con el mapper están en inglés y su interfaz es poco intuitiva para usuarios de lectores de pantalla.
	2. Como se dijo arriba, por ahora solo se soportan mapas de ZMud, pero se espera poder añadir soporte para mapas de CMud y Mudlet (incluso de tintin) en el futuro.
	3. No posee un modo de edición.
]]>
</description>

</plugin>


<!--  Triggers  -->










<triggers>
  <trigger
   enabled="y"
   match="^&prefijo;Cola de comandos borrada \(\'peleas parar\' detendrá los ataques si es lo que querías\)\.$"
   regexp="y"
   sequence="100"
   script="on_stop"
  >
  </trigger>
</triggers>

<triggers>
  <trigger
   enabled="y"
   group="General"
   lines_to_match="2"
   match="^&prefijo;(?P&lt;room_name&gt;.*?)\n\s\[(?P&lt;exits&gt;[a-z\|\-\~\*\,]*)\] \((?P&lt;branches&gt;[a-z\|\-\~\*\,]*)\)\ $"
   multi_line="y"
   regexp="y"
   script="on_mirar"
   sequence="100"
  >
  </trigger>
  <trigger
   enabled="y"
   group="General"
   keep_evaluating="y"
   match="^&prefijo;(?P&lt;room_name&gt;.*?) \[(?P&lt;exits&gt;[a-z\|\-\~\*\,]*)\]\ $"
   name="mirar"
   regexp="y"
   script="on_mirar"
   sequence="100"
   lowercase_wildcard="y"
  >
  </trigger>
</triggers>

<!--  Aliases  -->

<aliases>
  <alias
   script="on_ver"
   match="mapa ver"
   enabled="y"
   sequence="100"
   group="debug"
  >
  </alias>


  <alias
   script="on_limpiar"
   match="mapa olvidar"
   enabled="y"
   sequence="100"
  >
  </alias>
  
  <alias
   script="on_pedir"
   match="q *"
   enabled="y"
   group="Debug"
   sequence="100"
  >
  </alias>

  <alias
   script="on_importar"
   match="mapa importar"
   enabled="y"
   sequence="100"
  >
  </alias>

  <alias
   script="on_buscar"
   match="mapa buscar"
   enabled="y"
   sequence="100"
  >
  </alias>

  <alias
   script="on_ir"
   match="mapa navegar *"
   enabled="y"
   sequence="100"
  >
  </alias>

  <alias
   script="on_mostrar"
   match="mapa mostrar"
   enabled="y"
   sequence="100"
  >
  </alias>

  <alias
   script="on_ocultar"
   match="mapa ocultar"
   enabled="y"
   sequence="100"
  >
  </alias>

  <alias
   match="mapa editar"
   script="on_editar"
   sequence="100"
   enabled="y"
  >
  </alias>
  
  <alias
   match="^mapa setsala (?P&lt;id&gt;\d*?)$"
   script="on_posicionar"
   regexp="y"
   enabled="y"
   sequence="100">
  </alias>

  <alias
   match="^mapa conectar (?P&lt;id&gt;\d*?) (?P&lt;hacia&gt;\w*?) (?P&lt;desde&gt;\w*?)$"
   regexp="y"
   sequence="100"
   script="on_conectar"
   enabled="y"
  >
  </alias>
</aliases>

<!--  Script  -->
<script>
<![CDATA[
require "rl_stuff"
require "mapper"
require "copytable"
require "serialize"
require "var"
require "ppi"

-- La base de datos
local db = nil
local db_name = GetInfo(67).."mapa_rl.sqlite"

-- Las salas ya cargadas y cacheadas
local rooms = {}

-- La config (exigida por el módulo del mapper)
local config = {}

-- Posición actual en el mapa e historial de posiciones.
local current = {}

-- Datos para el modo edición
local editar = {
	dirs = {},
	slugs = {},
}

-- Datos variados
local data = {}

-- Un mapeo de salidas para poder saber cuales son válidas
local mapa_salidas = {
	n = "n",
	norte = "n",
	north = "n",
	ne = "ne",
	noreste = "ne",
	e = "e",
	este = "e",
	east = "e",
	se = "se",
	sudeste = "se",
	s = "s",
	sur = "s",
	south = "s",
	so = "sw",
	sw = "sw",
	sudoeste = "sw",
	o = "w",
	oeste = "w",
	west = "w",
	w = "w",
	no = "nw",
	noroeste = "nw",
	nw = "nw",
	ar = "u",
	arriba = "u",
	up = "u",
	ab = "d",
	abajo = "d",
	down = "d",
	fuera = "fu",
	dentro = "de",
	puerta = "pu"
}

-- Para obtener la salida inversa en el modo de edición
local salidas_inversas = {
	e = "w",
	w = "e",
	s = "n",
	n = "s",
	se = "nw",
	nw = "se",
	ne = "sw",
	sw = "ne",
	u = "d",
	d = "u",
}

-- Esta tabla contiene nombres largos para las salidas. Usado sobre todo para mostrar correctamente los nombres dentro del plugin
local salidas_localizadas = {
	e = "este",
	w = "oeste",
	n = "norte",
	s = "sur",
	nw = "noroeste",
	ne = "noreste",
	sw = "suroeste",
	se = "sudeste",
	u = "arriba",
	d = "abajo",
	fu = "fuera",
	de = "dentro",
}

local enviar = {
	w = "o",
	west = "o",
	sw = "so",
	nw = "no",
	u = "ar",
	up = "ar",
	d = "ab",
	down = "ab",
	north = "n",
	south = "s",
	east = "e",
}

-- Tomado y adaptado de www.gammon.com/db
local function query(qs, valores)
	qs = utf8convert(qs)
	-- Lo primero es preparar la consulta
	local stmt, success, err_message = db:prepare (qs)
	
	-- Comprobamos que haya devuelto algo, sino es error.
	assert(stmt, db:errmsg())
	
	-- asignar los valores de la tabla
	if valores and type(valores) == "table" then
		stmt:bind_names(valores)
	end -- tables
	
	local filas = {}
	for fila in stmt:nrows() do
		table.insert(filas, fila)
	end -- nrows
	
	local errcode = stmt:finalize()
	assert(errcode == 0, "Ocurrió un error al ejecutar la consulta. Error "..errcode..".")
	return filas
end -- query

-- Una corrutina para cargar las salas en segundo plano, una a la vez
local function cargar_salas()
	while not db or not db:isopen() do
		coroutine.yield(true)
	end -- while
	
	local success, salas = pcall(query,[[
		select sala_id from salas
	]])
	
	assert(success, "No se pudo leer la base de datos.")
	
	-- Contamos cuantas son
	local success2, cuenta = pcall(query,[[
		select count(*) as contador from salas
	]])
	
	assert(success2, "No se pudieron contar las salas por alguna razon.")
	
	coroutine.yield("Cargando las salas ...")
	
	if cuenta.contador == 0 then
		-- No hay ninguna necesidad de que el usuario sepa de algo que pasa en segundo plano.
		return
	end -- if

	local contar = 0
	
	for id = 1, #salas do
		getRoom(salas[id].sala_id)

		-- Al final no resulta práctico cargar 25 salas por segundo, así que aumentamos

		-- Aumentamos el contador
		contar = contar + 1

		if contar == 100 then
			contar = 0
			coroutine.yield()
		end -- if
	end -- ids
	coroutine.yield("Se cargaron todas las salas.")
end -- function

local function elegir_sala(uids)
	local lista = {}
	local cuenta = 0

	-- Simplificamos todo retornando el primer valor si hay solamente uno ...
	if #uids == 1 then
		return tonumber(uids[1])
	end -- uids

	for k, v in pairs(uids) do
		local sala = getRoom(v)

		local item = string.format("%s\nSalidas:\n", sala.name)
		
		for i, j in pairs(sala.exits) do
			local otra_sala = getRoom(j)
			
			item = item..string.format("%s: %s\n", i, getRoom(j).name)
		end -- exits
		
		lista[sala.id] = utf8convert(item)
		cuenta = cuenta + 1
	end -- uids
	
	return utils.listbox("Selecciona una sala",
		string.format("Se encontraron %d salas en total. Elige una para seleccionarla.", cuenta),
		lista)
end -- function

function getRoom(uid)
	local room = rooms[uid]
	
	if not room then
		room = {}

		assert(type(uid) == "number", "El UID pasado no es válido.")

		if query("select count(*) as count from salas;")[1].count == 0 then
			mapper.mapprint("No hay salas cargadas. Considera importar un mapa")
		end -- query

		local success, result, error = pcall(query,[[
			select sala_id, nombre
			from salas
			where sala_id = :uid;
		]], {uid = uid})

		assert(success)

		room.id = result[1].sala_id
		room.name = utf8convert(result[1].nombre)
		room.exits = {}
		
		success, result = pcall(query,[[
			select * from salidas
			where desde_id = :uid;
		]], {uid = uid})

		for k, v in pairs(result) do
			room.exits[v.nombre] = v.hasta_id
		end -- for in result
		
		rooms[room.id] = room
	end -- room
	
	-- room = copytable.shallow(room)
	
	room.overmessage = room.name
	
	return room
end -- GetRoom

local function guardar_sala(sala)
	local result, result2
	assert(db:isopen())
	
	-- Si la sala tiene un ID, significa que ya está guardada en la base de datos
	if not sala.id then
		result = query([[
			insert into salas (nombre)
			values (:nombre);
		]], {nombre = sala.name})
		
		-- Como el motor no devuelve nada, tenemos que buscar por nosotros mismos el ID de la sala tras cargarla
		sala.id = db:last_insert_rowid()
		assert(sala.id and sala.id > 0, "Error al insertar la sala. ID no válido.")
		
		-- Ya que estamos guardando la sala por primera vez, no es necesario actualizar las salidas, simplemente insertarlas
		if sala.exits then
			for k, v in pairs(sala.exits) do
				result = query([[
					insert into salidas (desde_id, hasta_id, nombre)
					values (:desde_id, :hasta_id, :nombre);
				]], {desde_id = sala.id, hasta_id = v, nombre = k})

			end -- for sala.exits
		end -- sala.exits
		
	else
		-- Esto es para cambiar alguna información de la sala, como por ejemplo el nombre, la dirección de alguna salida, o el nombre de la dirección de alguna salida.
		
		-- Primero la sala en sí, que es la parte mas fácil
		result = query([[
			update salas set nombre = :nombre
			where sala_id = :sala_id;
		]], {sala_id = sala.id, nombre = sala.name})
		
		-- Sería bastante raro ver esto en una sala que se actualiza contra la base de datos, pero de todos modos lo ponemos
		if sala.exits then
			-- Este caso es un poco mas complicado

			-- primero que nada, tenemos que saber qué salidas están registradas en la base de datos
			local salidas_db = query([[
				select * from salidas
				where desde_id = :desde_id;
			]], {desde_id = sala.id})
			
			-- También necesitamos guardar en una lista las salidas que ya existen en la base de datos y que ya hemos procesado:
			local salidas_existentes = {}
			local salidas_cambiadas = {}
			
			-- en segundo lugar, tenemos que recorrer los resultados
			for k, v in pairs(salidas_db) do
				-- en este punto pueden darse varios casos posibles
				
				if not sala.exits[v.nombre] then -- aparentemente cambió el nombre de la salida
					salidas_cambiadas[v.hasta_id] = true
				elseif sala.exits[v.nombre] ~= v.hasta_id then -- cambia la sala a la que lleva esta salida
					result = query([[
						update salidas set hasta_id = :hasta_id
						where desde_id = :desde_id and hasta_id = :orig_hasta_id;
					]], {hasta_id = sala.exits[v.nombre], desde_id = v.desde_id, orig_hasta_id = v.hasta_id})
				end -- if
				
				-- recordamos la salida, para no tener que procesarla denuevo
				salidas_existentes[v.nombre] = true
			end -- salidas_db
			
			-- Luego de pasar por las de la db, pasamos por la de la sala cargada para guardarlas
			for k, v in pairs(sala.exits) do
				if salidas_cambiadas[v] then
					results = query([[
						update salidas set nombre = :nombre
						where desde_id = :desde_id and hasta_id = :hasta_id;
					]], {nombre = k, desde_id = sala.id, hasta_id = v})
				elseif not salidas_existentes[k] then
					result = query([[
						insert into salidas (desde_id, hasta_id, nombre)
						values (:desde_id, :hasta_id, :nombre);
					]], {desde_id = sala.id, hasta_id = v, nombre = k})
				end -- salidas_existentes
			end -- for sala.exits
		end -- sala.exits
	end -- sala.id
	
	return sala
end -- guardar_sala

local function importar_sala(room)
	local result
	local sala = {
		name = room.Name
	}

	-- antes de procesarla, comprobamos que ya no haya sido importada:
	if query([[
			select count(*) as 'exists' from salas_importadas
			where id_viejo = :ObjId;
		]], room)[1].exists == 0 then
		sala = guardar_sala(sala)

		if sala then
			result = query([[
				insert into salas_importadas (id_viejo, id_nuevo)
				values(:viejo_id, :nuevo_id);
			]], {viejo_id = room.ObjId, nuevo_id = sala.id})
		end -- guardar_sala
	else
	
	end -- if

end -- function

local function salidaValida(salida, sala)
	local mi_sala

	assert(salida, "No se proporcionó una salida.")
	
	-- La sala tiene que ser de tipo number y la salida de tipo string
	assert(type(sala) == "number" or type(sala) == "nil", "La sala solo puede ser un número.")
	assert(type(salida) == "string", "La salida solo puede ser una cadena.")
	
	-- Lo primero es ver si hay una sala. En ese caso, obtenemos el objeto de sala correspondiente
	if sala then
		mi_sala = assert(getRoom(sala), "No se pudo encontrar ninguna sala con el ID proporcionado.")
	end -- if
	
	-- Si no hay una sala, solo podemos devolver con seguridad las direcciones cardinales básicas, en inglés.
	-- De todos modos, no sé por qué incluyo esto...
	if not mi_sala then
		return mapa_salidas[salida]
	end --if
	
	-- En caso de tener una sala válida, podemos devolver datos mas seguros.
	if mi_sala.exits[salida] then
		return salida
	elseif mi_sala.exits[mapa_salidas[salida]] then
		return mapa_salidas[salida]
	end -- if
end -- function

local function desdeSalida(sala, salida)
	assert(sala, "No se proporcionó una sala válida.")
	assert(salida, "No se proporcionó una salida.")
	
	-- La sala tiene que ser de tipo number y la salida de tipo string
	assert(type(sala) == "number", "La sala solo puede ser un número.")
	assert(type(salida) == "string", "La salida solo puede ser una cadena.")
	
	-- No es necesario ningún proceso complejo
	return assert(getRoom(sala).exits[salidaValida(salida, sala)], string.format("No se encuentra ninguna sala en dirección a %s.", salida))
end -- function

local function mover(sala)
	local dest_sala
	assert(sala, "No se proporcionó un Id de sala ni una dirección.")
	assert(type(sala) == "number" or type(sala) == "string", "La sala tiene que ser un Id numérico o una salida.")

	-- Lo primero es encontrar la sala por su ID, si el dato es numérico
	if type(sala) == "number" then
		dest_sala = assert(getRoom(sala), "La sala proporcionada no se pudo encontrar en la base de datos.")
	else
		local mi_sala

		-- En caso de que sea una string, sencillamente buscamos entre las salidas de la sala actual.

		-- Puede que no haya una sala actual, por lo que sencillamente salimos para evitarnos problemas
		if not current.room then
			return
		end -- if

		-- Evitamos errores
		local success, s_id = pcall(desdeSalida, current.room, sala)

		-- Si no hay éxito, significa que nos falta mapear una sala
		if not success then

			-- Si el modo de edición no está habilitado, salimos.
			if not var.editar then
				-- Limpiamos los datos, pues no hay salida mapeada ni estamos en modo de edición.
				current = {}
				mapper.hide()
				return
			end -- if
			
			-- Creamos una sala básica
			local sala_nueva = {
				name = data.nombre,
				exits = {}
			}
			
			local anterior = getRoom(current.room)

			-- Si la salida es estándar, sencillamente registramos la inversa
			if mapa_salidas[sala] then
				sala_nueva.exits[salidas_inversas[mapa_salidas[sala]]] = anterior.id
			end -- if

			db:exec("begin transaction;")
			
			-- Guardamos la sala nueva para poder obtener el ID
			local guardada = pcall(guardar_sala, sala_nueva)

			if not guardada then
				db:exec("rollback;")
				assert(guardada, db:errmsg())
			end

			-- Registramos la salida desde la sala anterior a esta.
			anterior.exits[mapa_salidas[sala] or sala] = sala_nueva.id

			-- guardamos la otra sala
			guardada = pcall(guardar_sala,anterior)

			if not guardada then 
				db:exec("rollback;")
				assert(guardada, db:errmsg())
			end
			
			db:exec("commit transaction;")
			
			mi_sala = sala_nueva
		else
			mi_sala = getRoom(s_id)
		end -- if
		
		dest_sala = mi_sala
	end -- if
	
	assert(dest_sala, "No se pudo encontrar ninguna sala válida. Sala: '${sala}'" % {sala=sala})
	
	-- Terminadas las comprobaciones, mostramos la sala en el mapa y la ponemos como current.room
	if current.prev and current.prev.room == dest_sala.id then
		current = current.prev
	else
		current = {
			room = dest_sala.id,
			last_dir = (function()
				if type(sala) == "string" then
					return sala
				end -- if
			end)(),
			prev = current
		}
	end -- if
	
	-- Posicionamos el mapa
	mapper.draw(dest_sala.id)
	
	-- Guardamos la sala en una variable externa, por si acaso
	var.sala = dest_sala.id
end -- mover

local function findRoomByName(name)
	local success, result, message = pcall(query,[[
		select sala_id from salas
		where nombre = :room_name;
	]], {room_name = name})
	
	assert(result, "Error: ${message}" % {message = message})
	
	return result
end -- findRoomByName

local function findRoomsWithNameContaining(pattern)
	local success, result, message = pcall(query,[[
		select sala_id from salas
		where nombre like '%' || :patron || '%';
	]], {patron = utils.utf8convert(pattern)})
	
	assert(success, "Error: ${result}" % {result = message})

	return result
end -- function

function mover_gmcp(mensaje, dir)
	mover(dir:sub(2,dir:len()-1))
	if not current.room then
		local rooms = findRoomsWithNameContaining(data.nombre)
		
		if #rooms == 1 then
			mover(rooms[1].sala_id)
			
			if not var.oculto then
				mapper.show()
			end -- oculto
		end -- if
	end -- current.room
end -- function

local function countRoomsWithNameContaining(name)
	local success, result = pcall(query, [[
		select count(*) as count from salas
		where nombre like '%' || :patron || '%';
	]], {patron = name})

	assert(success, "No se pudo contar el número de salas.")
	return result.count
end -- function

function OnPluginConnect()
	current = {}
end -- OnPluginConnect

function OnPluginDisconnect()
	current = {}
	var.sala = nil
	mapper.hide()
end -- OnPluginDisconnect

function OnPluginListChanged()
	RLStuffListChanged()
	
	subscribir("Room.Movimiento", "mover_gmcp")
end -- function

function OnPluginInstall()
	db = sqlite3.open(db_name)
	local q = query("select * from sqlite_master where type = 'table' and name = 'salas';")
	
	if #q == 0 then
		local result = db:exec([[
			BEGIN TRANSACTION;

			-- Table: hash_salas
			CREATE TABLE hash_salas (
				slug    TEXT    NOT NULL,
				sala_id INTEGER NOT NULL
								DEFAULT 0
			);


			-- Table: salas
			CREATE TABLE salas (
				sala_id INTEGER PRIMARY KEY AUTOINCREMENT
								NOT NULL,
				nombre  TEXT    NOT NULL,
				zona_id INTEGER REFERENCES zonas (zona_id) ON DELETE SET NULL
			);


			-- Table: salas_importadas
			CREATE TABLE salas_importadas (
				importacion_id    INTEGER  PRIMARY KEY AUTOINCREMENT
										   NOT NULL,
				id_viejo          INTEGER  NOT NULL
										   DEFAULT 0,
				id_nuevo          INTEGER  NOT NULL
										   DEFAULT 0
										   REFERENCES salas (sala_id) ON DELETE CASCADE,
				fecha_importacion DATETIME NOT NULL
										   DEFAULT CURRENT_TIMESTAMP
			);


			-- Table: salidas
			CREATE TABLE salidas (
				salida_id       INTEGER PRIMARY KEY AUTOINCREMENT
										NOT NULL,
				desde_id        INTEGER NOT NULL
										REFERENCES salas (sala_id) ON DELETE CASCADE,
				hasta_id        INTEGER NOT NULL
										REFERENCES salas (sala_id) ON DELETE CASCADE,
				nombre          TEXT    NOT NULL,
				comando_antes   TEXT,
				comando_despues,
				UNIQUE (
					desde_id ASC,
					hasta_id DESC
				)
			);


			-- Table: salidas_importadas
			CREATE TABLE salidas_importadas (
				id_viejo          INTEGER  NOT NULL,
				id_nuevo          INTEGER  REFERENCES salidas (salida_id) ON DELETE CASCADE
										   NOT NULL,
				fecha_importacion DATETIME DEFAULT (datetime() ),
				UNIQUE (
					id_viejo ASC,
					id_nuevo DESC
				)
			);


			-- Table: zonas
			CREATE TABLE zonas (
				zona_id INTEGER PRIMARY KEY AUTOINCREMENT
								NOT NULL,
				nombre  TEXT    NOT NULL,
				color   INTEGER
			);


			-- Index: salas_hashes
			CREATE UNIQUE INDEX salas_hashes ON hash_salas (
				"slug" ASC,
				"sala_id" ASC
			);


			-- Index: salas_zonas
			CREATE INDEX salas_zonas ON salas (
				zona_id ASC
			);


			-- Index: salidas_desde_hasta
			CREATE UNIQUE INDEX salidas_desde_hasta ON salidas (
				"desde_id" ASC,
				"hasta_id" DESC
			);


			COMMIT TRANSACTION;
		]])
	end -- if
	local init_config = {
		config = config,
		get_room = getRoom,
		show_help = OnHelp,
		show_up_down = true,
		-- speedwalk_prefix = GetInfo(21),
	}
	
	mapper.init(init_config)
	config.SCAN.depth = 5000
	config.delay = 0

	if var.oculto then
		mapper.hide()
	end -- if
	
	agregarCoro("cargar", cargar_salas)
	
	if IsConnected() and var.sala then
		mover(tonumber(var.sala))
	end -- sala
end -- OnPluginInstall

function OnPluginSend(texto)
	if current.room then
		local mov_valido = salidaValida(texto, current.room)
		
		if mov_valido then
			SendImmediate(enviar[mov_valido] or mov_valido)
			return false
		end -- if
	end -- if
end -- function

function OnPluginRemove()
	db:close()
end -- OnPluginRemove

function OnPluginEnable()
	if IsConnected() and not var.oculto then
		mapper.show()
	end -- if
end -- function

function OnPluginDisable()
	mapper.hide()
end -- function

function on_mirar(name, line, wildcards, style)
	data.nombre = wildcards.room_name
	data.salidas = wildcards.exits
end -- on_mirar

local function mostrar_consulta(resultado)
	assert(resultado, "No hay ningún resultado.")
	assert(type(resultado) == "table", "No se pasaron los resultados de una tabla.")
	
	-- Este sería el caso típico, pares de clave/valor.
	if #resultado == 0 then
		for k, v in pairs(resultado) do
			if type(v) == "table" then
				mostrar_consulta(v)
			elseif type(v) == "string" then
				mapper.mapprint(string.format("%s: %s", k, utf8convert(v)))
			else
				mapper.mapprint(string.format("%s: %s", k, v))
			end -- if
			
		end -- if
	else
		for k, v in ipairs(resultado) do
			mapper.mapprint(string.format("Registro %i:", k))
			mostrar_consulta(v)
			print()
			print()
		end -- for
	end -- if
end -- function

function on_pedir(name,line,wildcards)
	local success, result = pcall(query,wildcards[1])

	if success then
		local count = 0
		
		if #result == 0 then
			mapper.mapprint("No hay registros para mostrar")
			return
		end -- #result

		if #result == 1 then
			mapper.mapprint("Registro único:")
			print()
			result = result[1]
		end -- if

		mostrar_consulta(result)
	else
		mapper.maperror(result)
	end -- if
end -- on_pedir

function on_ver()
	if not current.room then
		mapper.mapprint("No hay ninguna sala reconocida")
		return
	end -- if
	
	local sala = getRoom(current.room)
	
	mapper.mapprint([[
		Nombre: ${name}
		ID: ${id}
		
		Salidas:
	]] % sala)
	
	
	for k, v in pairs(sala.exits) do
		mapper.mapprint("			${salida}: ${destino}" % {salida = salidas_localizadas[k] or k, destino = getRoom(v).name})
	end -- exits
	
	mapper.mapprint("		Fin")
end -- function

function on_importar()
	local archivo = utils.filepicker("Cargar mapa", nil, nil,
					{["*"] = "Todos los archivos",
					mdb = "Base de datos de Access"})

	if not archivo then
		return
	end -- if
	
	agregarCoro("importar", function()
		require("luacom")
		
		-- Primero que nada tenemos que abrir la base de datos que contiene el mapa de zmud
		local zmud_db = luacom.CreateObject("ADODB.Connection")
		zmud_db:Open(string.format("Provider=Microsoft.Jet.OLEDB.4.0;Data Source=%s", archivo))
		
		assert(zmud_db.State == 1, "No se abrió la base de datos.")
		
		-- Esta función lee las salas desde la base de datos y no hace nada mas.
		local leer_access = coroutine.create(function(access_db)
			local rs = access_db:Execute("select count(*) from ObjectTbl;")
			rs:MoveFirst()
			local result = rs.Fields:Item(0).Value
			rs:close()
			coroutine.yield(result)
			
			rs = access_db:Execute("select ObjId, Name from ObjectTbl;")
			rs:MoveFirst()
			
			while not rs.EOF do
				coroutine.yield({
					ObjId = tonumber(rs.Fields:Item("ObjId").Value),
					Name = rs.Fields:Item("Name").Value
				})
				
				rs:MoveNext()
			end -- EOF
			
			rs:Close()
		end) -- database loader

		-- Esta hace lo que la anterior, pero con las salidas
		local leer_salidas = coroutine.create(function(access_db)
			local rs = access_db:Execute("select count(*) from ExitTbl;")
			
			rs:MoveFirst()
			local result = rs.Fields:Item(0).Value
			rs:close()
			coroutine.yield(result)
			
			rs = access_db:Execute([[
				select ExitId, FromId, ToId, DirName from ExitTbl inner join DirTbl
				on ExitTbl.DirType = DirTbl.DirId-1
				union select ExitId, FromId, ToId, Name from ExitTbl
				where DirType = -1
				or DirType = 10
				or DirType = 11;
			]])

			rs:MoveFirst()
			while not rs.EOF do
				local row = {
					ExitId = tonumber(rs.Fields:item(0).Value),
					FromId = tonumber(rs.Fields:Item(1).Value),
					ToId = tonumber(rs.Fields:Item(2).Value),
					DirName = rs.Fields:Item(3).Value,
				}
				coroutine.yield(row)
				rs:MoveNext()
			end -- while
			
			rs:Close()
		end)

		local success, result = coroutine.resume(leer_access, zmud_db)
		local sala_count = result
		local current = 0
		coroutine.yield(string.format("Se encontraron %i salas en la base de datos.", sala_count))


		local importar_salidas = coroutine.create(function()
			local q = query("select * from salas_importadas;")
			local ids_nuevos = {}
			
			for k, v in pairs(q) do
				ids_nuevos[tonumber(v.id_viejo)] = tonumber(v.id_nuevo)
			end -- for
			
			local continue, salida = coroutine.yield()
			local debugged = false
			while continue do
				local datos = {
					desde = ids_nuevos[tonumber(salida.FromId)],
					hasta = ids_nuevos[tonumber(salida.ToId)],
					nombre = mapa_salidas[salida.DirName] or salida.DirName
				}


				local exists = query([[
					select count(*) count from salidas
					where desde_id = :desde
					and hasta_id = :hasta;
				]], datos)[1]

				if not debugged and (not datos.desde or not datos.hasta) then
					require("tprint")
					tprint(datos)
					tprint(sala)
					debugged=true
				end -- if

				if exists.count == 0 then
					local success, result = pcall(query, [[
						insert into salidas (desde_id, hasta_id, nombre)
						values (:desde, :hasta, :nombre);
					]], datos)
					
					if success then
						-- Registramos que esta salida se importó desde la base de datos
						success, result = pcall(query,[[
							insert into salidas_importadas (id_viejo, id_nuevo)
							values(:viejo, :nuevo);
						]], {viejo = salida.ExitId, nuevo=db:last_insert_rowid()})
						
						assert(success, result)
					end -- success
				end -- if
				
				continue, salida = coroutine.yield()
			end -- while
		end) -- function

		-- Lo primero es empezar una transacción
		query("begin transaction")
		
		result, sal_count = coroutine.resume(leer_salidas, zmud_db)
		coroutine.yield(string.format("Se han encontrado %i conexiones en la base de datos.", sal_count))

		-- Este es un control para que no se ejecute todo el código en un solo tick
		local pasadas = 0

		while coroutine.status(leer_access) ~= "dead" do
			success, result = coroutine.resume(leer_access)
			
			if success then
				if result then importar_sala(result) end
			else
				coroutine.yield(string.format("Error: %s", result))
				db:exec("rollback;")
				return
			end -- if

			local errcode = db:errcode()
			assert(errcode == 0 or errcode == 100 or errcode == 101, db:errmsg())
			
			pasadas = pasadas + 1
			if pasadas == 200 then
				coroutine.yield()
				pasadas = 0
			end -- if
		end -- while

		coroutine.resume(importar_salidas)
		while coroutine.status(leer_salidas) ~= "dead" do
			local success, salida = coroutine.resume(leer_salidas)
			
			if not success then
				coroutine.yield(string.format("Error: %s", salida))
				db:exec("rollback;")
				return
			end -- if
			
			if salida then
				success, message = coroutine.resume(importar_salidas, true, salida)
				local errcode = db:errcode()
				if not (errcode == 0 or errcode == 100 or errcode == 101) then
					coroutine.yield(db:errmsg())
					db:exec("rollback;")
					return
				end -- if
			end -- if
			
			pasadas = pasadas + 1
			if pasadas == 200 then
				coroutine.yield()
				pasadas = 0
			end -- if
		end -- while
		
		coroutine.resume(importar_salidas, false)
		zmud_db:Close()
		zmud_db = nil
		
		query("commit;")
		coroutine.yield("La importación se realizó correctamente.")
		rooms = {}
		agregarCoro("cargar", cargar_salas)
	end) -- function
end -- function

function on_buscar(name, line, wildcards)
	if not data.nombre then
		mapper.maperror "No hay datos con qué buscar."
	end -- if
	
	local ids = {}
	
	for k, v in pairs(findRoomsWithNameContaining(data.nombre)) do
		table.insert(ids, v.sala_id)
	end -- findRoomByName 1
	
	local sala = elegir_sala(ids)
	
	if sala then
		mover(sala)
	end -- selected
end -- function

function on_ir(name, line, wildcards)
	-- Si no hay una sala reconocida, salimos
	if not current.room then
		mapper.maperror("No tengo idea de donde estás.")
		return
	end -- if
	
	-- Un contador para prevenir cuelgues
	local salas = findRoomsWithNameContaining(wildcards[1])
	local counter = 0

	-- Esta es la función que usamos para buscar las salas
	local function prueba(x)
		-- Si ya tenemos el contador al máximo, salimos
		if counter == #salas then
			return false, true
		end -- counter

		for k, v in pairs(salas) do
			if x == tonumber(v.sala_id) then
				counter = counter + 1

				if counter == #salas then
					-- Si ya encontramos todas, tenemos que devolver un segundo true para que no se continúe la búsqueda
					return true, true
				end -- if

				-- La sala es válida
				return true
			end -- if
		end -- salas

		-- Claro está, no encontramos nada
		return false
	end -- prueba

	mapper.find(prueba, false, 20, true)
end -- on_ir

function on_limpiar(name, line, wildcards)
	if not current.room then
		mapper.mapprint("No hay ninguna sala.")
	else
		mapper.mapprint("Olvidando la sala actual...")
		current = {}
	end -- if
end -- function

function on_mostrar()
	if not var.oculto then
		mapper.mapprint("El mapa ya se muestra.")
		return
	end -- if
	
	var.oculto = false
	mapper.show()
	mapper.mapprint("Se mostró el mapa.")
end -- function

function on_ocultar()
	if var.oculto then
		mapper.mapprint("El mapa ya est[a oculto.")
		return
	end -- var.oculto
	
	var.oculto = true
	mapper.hide()
	mapper.mapprint("Se ocult[o el mapa")
end -- function

function OnHelp ()
	mapper.mapprint (world.GetPluginInfo (world.GetPluginID (), 3))
end

function on_stop()
	mapper.cancel_speedwalk()
end -- on_stop

function on_editar(name,line,wc)
	if not var.editar then
		mapper.mapprint("Activando el modo de edición del mapa.")
		var.editar = true
	else
		mapper.mapprint("Modo de edición desactivado.")
		var.editar = nil
	end -- if
end -- function

function on_posicionar(n,l,wc)
	mapper.mapprint(string.format("Estableciendo la sala %i como la sala actual.", wc.id))
	mover(tonumber(wc.id))
end -- function

function on_conectar(name,line,wildcards)
	local desde = getRoom(current.room)
	local hasta = getRoom(tonumber(wildcards.id))
	
	if not desde then
		mapper.maperror("No hay ninguna sala reconocida.")
		return
	end -- if
	
	if not hasta then
		mapper.maperror("La sala con la que se quiere conectar no existe.")
		return
	end -- if
	
	local conectar = utils.msgbox(string.format("Se va a conectar con la sala %s. Proseder?", hasta.name), "Editar mapa", "yesno")
	
	if conectar == "yes" then
		desde.exits[mapa_salidas[wildcards.hacia] or wildcards.hacia] = hasta.id
		hasta.exits[mapa_salidas[wildcards.desde] or wildcards.desde] = desde.id
		db:exec("begin transaction;")
		guardar_sala(desde)
		guardar_sala(hasta)
		db:exec("commit transaction;")
		rooms[desde.id] = nil
		rooms[hasta.id] = nil
		getRoom(desde.id)
		getRoom(hasta.id)
		mapper.draw(current.room)
	end -- if
end -- on_conectar

]]>
</script>


<!--  Plugin help  -->

<aliases>
  <alias
   script="OnHelp"
   match="mapa ayuda"
   enabled="y"
  >
  </alias>
</aliases>

<script>
<![CDATA[


]]>
</script> 

</muclient>
